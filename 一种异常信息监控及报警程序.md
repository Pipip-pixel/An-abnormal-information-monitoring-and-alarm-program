# 监控程序文档

该文档详细介绍了监控项目的功能、核心模块及其实现方式，并为项目的扩展提供了指导。项目的主要功能是实时监控并处理三个指标（X、Y、Z），并在特定条件下进行告警处理。该项目使用了Flask作为 Web框架，并结合了数据库、定时任务和邮件通知等功能。

# 项目结构概述

项目主要由以下部分构成：

Flask**应用（**app.py**）**：包含Flask应用的配置、路由及请求处理。

**数据处理（**my_process.py**）**：包含对实时数据的处理、数据库操作和告警通知逻辑。**数据库模型（**model.py**）**：定义了数据库中的数据表及其交互方法。

**控制器（**controller.py**）**：封装了外部API调用及告警处理功能。

**登录（**login.py**）**:封装几个系统的登录逻辑，如果新增系统按此扩展即可**日志模块（**my_logger.py**）**：提供项目日志记录功能，方便排查问题。

**请求模块（**my_requests**）**：封装了统一的http请求，覆盖异常处理、日志打印、请求重试等**常用函数（**common.py**）**：包含一些常用的辅助函数，如发送邮件、获取监控数据等。

# 功能说明

- 1.  Flask Web **服务（**app.py**）**

是Web应用的主要入口，包含了各个HTTP路由的定义，用于接收用户请求并进行处理。以下是几个重要的路由：

app.py

**（**GET**）**

/get_current_values

该路由查询数据库中RealtimeMonitor 表的最新记录，并返回X、Y、Z三项数据的值。

@app.route('/get_current_values', methods=\['GET'\]) def get_current_values():

record = RealtimeMonitor.query.all() x = record\[0\].value

y = record\[1\].value

z = record\[2\].value

return jsonify({

'x': x if x else 0, 'y': y if y else 0, 'z': z if z else 0

})

**（**GET / POST**）**

/monitor

请求：返回monitor.html 页面。

GET

请求：返回所有已触发告警的记录，以JSON格式响应。

POST

@app.route('/monitor', methods=\['GET', 'POST'\]) def monitor():

if request.method == 'POST': records =

MonitorRecord.query.filter(MonitorRecord.alert).order_by(MonitorRecord.id.desc()

).all()

records_dict = \[record.to_dict() for record in records\] return jsonify(records=records_dict)

else:

return render_template('monitor.html')

**（**DELETE**）**

/delete/&lt;int:id&gt;

根据传入的记录ID删除数据库中的记录。

@app.route('/delete/&lt;int:id&gt;', methods=\['DELETE'\]) def delete_record(\_id):

try:

record = MonitorRecord.query.get(\_id) if record:

db.session.delete(record) db.session.commit()

return jsonify({'success': True})

return jsonify({'error': 'Record not found'}), 404 except Exception:

logger.error(f"Error deleting record: {traceback.format_exc()}") return jsonify({'error': 'Server Error'}), 500

**（**POST**）**

/reset

重置告警，触发一个全局告警。

@app.route('/reset', methods=\['POST'\]) def reset_alert():

try:

send_alert('global')

return jsonify({'success': True}) except Exception:

logger.error(f"Error resetting alert: {traceback.format_exc()}") return jsonify({'success': False})

- 1.  **数据处理与告警（**my_process.py**）**

是数据处理的核心，负责定时从外部API获取数据并进行分析、告警处理。以下是几个

my_process.py

重要的功能：

update_realtime_monitor

更新实时监控数据表RealtimeMonitor 中的记录。

@staticmethod

def update_realtime_monitor(\_type, \_value): session = db.session()

try:

realtime_record = session.query(RealtimeMonitor).filter(RealtimeMonitor.\_type == \_type).first()

if realtime_record: realtime_record.\_value = \_value

realtime_record.timestamp = datetime.datetime.now() else:

new_record = RealtimeMonitor(\_type=\_type, \_value=\_value) session.add(new_record)

session.commit() except Exception as e:

session.rollback()

logger.error(f"更新实时数据失败，异常：{e}") finally:

session.close()

process_x , process_y ,

process_z

这些方法分别处理X、Y和Z指标的逻辑。当某个指标值超过预定阈值时，触发告警，并通过邮件通知用户。

@staticmethod

def process_x(x, last_x, token_b, recipient): DataProcessor.update_realtime_monitor(\_type=0, \_value=x) if x > last_x:

send_alert('x')

result_x = get_total_num(token_b, 'x')

alert_message_x_data = get_alert_message(token_b, "x", result_x) for msg in alert_message_x_data:

send_email(recipient, "监控告警-X", msg)

DataProcessor.update_database(\_type=0, \_value=x, alert_message=msg)

monitor_and_notify

该方法会根据获取到的X、Y、Z的最新数据进行告警处理，并通过线程同时处理X、Y、Z的监控逻辑。

@staticmethod

def monitor_and_notify(app): with app.app_context():

latest_record_type_0 = get_latest_record_by_type(0) latest_record_type_1 = get_latest_record_by_type(1)

last_x = latest_record_type_0 if latest_record_type_0 else 0 last_y = latest_record_type_1 if latest_record_type_1 else 0

token_a = loginA()

recipients = get_recipients_from_config() x, result_x = get_total_num(token_a, 'x') y, result_y = get_total_num(token_a, 'y') z = get_total_num_for_z(token_a)

token_b = loginB()

x_thread = threading.Thread(target=DataProcessor.process_x, args=(x, last_x, token_b, recipients))

y_thread = threading.Thread(target=DataProcessor.process_y, args=(y, last_y, token_b, recipients))

z_thread = threading.Thread(target=DataProcessor.process_z, args=(z, token_b, recipients))

x_thread.start() y_thread.start() z_thread.start()

x_thread.join() y_thread.join() z_thread.join()

start_scheduler

通过BackgroundScheduler 创建定时任务，每10秒执行一次monitor_and_notify 函数进行监控。

@staticmethod

def start_scheduler(app):

scheduler = BackgroundScheduler() scheduler.add_job(func=DataProcessor.monitor_and_notify, trigger='interval',

id='monitor_and_notify',

seconds=10, args=\[app\], max_instances=1)

scheduler.start() while True:

pass

## 扩展说明

### 扩展监控指标

要扩展新的监控指标（如W、V等），需要以下几个步骤：

- - - 1.  **数据库表扩展**：在RealtimeMonitor 表中添加新类型的字段，并且在

update_realtime_monitor 方法中添加对新字段的支持。

- - - 1.  **新增处理函数**：如process_w , process_v 等，分别处理对应指标的监控、告警和邮件通知。
            2.  **修改监控逻辑**：在monitor_and_notify 方法中添加新的线程，处理新指标的逻辑。

### 邮件通知系统扩展

可以通过扩展send_email 方法来支持不同的通知方式。例如，支持短信或即时消息通知时，可以在该方法中调用对应的API。

# 安装依赖

首先，确保你的环境中已经安装了Python 3.x（本项目使用3.11）。如果没有，请前往[Python官方网站](https://www.python.org/downloads/)下载安装。

- 1.  **创建虚拟环境（可选，本项目使用**Pycharm**集成**IDE**）**

推荐在虚拟环境中运行此项目，可以避免全局安装依赖包冲突。

\# 创建虚拟环境

python -m venv venv

\# 激活虚拟环境（Windows）

venv\\Scripts\\activate

\# 激活虚拟环境（Linux/Mac）

source venv/bin/activate

## 安装依赖

使用pip 安装项目所需的依赖包。依赖列表可以在requirements.txt 文件中找到。

pip install -r requirements.txt

或者你也可以手动安装项目中需要的包，以下是主要的依赖：

pip install Flask flask_sqlalchemy apscheduler flask_cors pip install sqlalchemy

pip install smtplib